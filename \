package listener

import (
	"fmt"
	"net"
	"sync"
)

type Listener struct {
	Port string
}

func New(p string) *Listener {
	return &Listener{
		Port: p,
	}
}

type Pub struct {
	pubs   map[net.Conn]bool
	msgQue chan string
}

func (p *Pub) Add(con net.Conn) {
	p.pubs[con] = true
}

func (l *Listener) Run() error {
	li, liErr := net.Listen("tcp", l.Port)

	if liErr != nil {
		return liErr
	}

	defer li.Close()

	Pub := &Pub{
		pubs: map[net.Conn]bool{},
	}

	go Pub.handleWrite()

	for {
		con, conErr := li.Accept()
		if conErr != nil {
			continue
		}

		Pub.Add(con)

		go handle(con, Pub)

	}
	// return nil
}

func handle(con net.Conn, p *Pub) {
	wg := sync.WaitGroup{}
	wg.Add(1)
	go handleRead(con, p)
	wg.Done()
	wg.Wait()
}

func (p *Pub) AddQue(str string) {
}

func handleRead(con net.Conn, p *Pub) {
	var data = make([]byte, 1000)

	for {
		len, err := con.Read(data)
		if err != nil {
			continue
		}
		p.msgQue <- string(data[:len])
		fmt.Println(string(data[:len]))
	}
}

func (p *Pub) handleWrite() {
	for {
		select {
		case msg := <-p.msgQue:
			for c, _ := range p.pubs {
				c.Write([]byte(msg))
			}
		}
	}
}
